diff --git a/cryptoapi/v2.0/nss_cryptoapi.c b/cryptoapi/v2.0/nss_cryptoapi.c
index a10590e..3a835dc 100644
--- a/cryptoapi/v2.0/nss_cryptoapi.c
+++ b/cryptoapi/v2.0/nss_cryptoapi.c
@@ -1365,107 +1365,89 @@
 
 /*
  * ABLK cipher algorithms
  */
 static struct crypto_alg cryptoapi_ablkcipher_algs[] = {
 	{
-		.cra_name = "cbc(aes)",
-		.cra_driver_name = "nss-cbc-aes",
-		.cra_priority = 10000,
-		.cra_flags = CRYPTO_ALG_TYPE_ABLKCIPHER | CRYPTO_ALG_ASYNC,
-		.cra_blocksize = AES_BLOCK_SIZE,
-		.cra_ctxsize = sizeof(struct nss_cryptoapi_ctx),
-		.cra_alignmask = 0,
-		.cra_type = &crypto_ablkcipher_type,
-		.cra_module = THIS_MODULE,
-		.cra_init = nss_cryptoapi_ablkcipher_init,
-		.cra_exit = nss_cryptoapi_ablkcipher_exit,
-		.cra_u = {
-			.ablkcipher = {
-				.ivsize = AES_BLOCK_SIZE,
-				.min_keysize = AES_MIN_KEY_SIZE,
-				.max_keysize = AES_MAX_KEY_SIZE,
-				.setkey = nss_cryptoapi_ablk_setkey,
-				.encrypt = nss_cryptoapi_ablk_encrypt,
-				.decrypt = nss_cryptoapi_ablk_decrypt,
-			},
-		},
+		.base = {
+			.cra_name = "cbc(aes)",
+			.cra_driver_name = "nss-cbc-aes",
+			.cra_priority = 10000,
+			.cra_flags = CRYPTO_ALG_TYPE_ABLKCIPHER | CRYPTO_ALG_ASYNC,
+			.cra_blocksize = AES_BLOCK_SIZE,
+			.cra_ctxsize = sizeof(struct nss_cryptoapi_ctx),
+			.cra_alignmask = 0,
+			.cra_module = THIS_MODULE,
+		},
+		.init = nss_cryptoapi_ablkcipher_init,
+		.exit = nss_cryptoapi_ablkcipher_exit,
+		.ivsize = AES_BLOCK_SIZE,
+		.min_keysize = AES_MIN_KEY_SIZE,
+		.max_keysize = AES_MAX_KEY_SIZE,
+		.setkey = nss_cryptoapi_ablk_setkey,
+		.encrypt = nss_cryptoapi_ablk_encrypt,
+		.decrypt = nss_cryptoapi_ablk_decrypt,
 	},
 	{
+		.base = {
 		.cra_name       = "rfc3686(ctr(aes))",
-		.cra_driver_name = "nss-rfc3686-ctr-aes",
-		.cra_priority   = 30000,
-		.cra_flags      = CRYPTO_ALG_TYPE_ABLKCIPHER | CRYPTO_ALG_ASYNC,
-		.cra_blocksize  = AES_BLOCK_SIZE,
-		.cra_ctxsize    = sizeof(struct nss_cryptoapi_ctx),
-		.cra_alignmask  = 0,
-		.cra_type       = &crypto_ablkcipher_type,
-		.cra_module     = THIS_MODULE,
-		.cra_init       = nss_cryptoapi_ablkcipher_init,
-		.cra_exit       = nss_cryptoapi_ablkcipher_exit,
-		.cra_u          = {
-			.ablkcipher = {
-				.ivsize         = CTR_RFC3686_IV_SIZE,
-/*
- * geniv deprecated from kernel version 5.0 and above
- */
-#if (LINUX_VERSION_CODE < KERNEL_VERSION(5, 0, 0))
-				.geniv          = "seqiv",
-#endif
-				.min_keysize    = AES_MIN_KEY_SIZE + CTR_RFC3686_NONCE_SIZE,
-				.max_keysize    = AES_MAX_KEY_SIZE + CTR_RFC3686_NONCE_SIZE,
-				.setkey         = nss_cryptoapi_ablk_setkey,
-				.encrypt        = nss_cryptoapi_ablk_encrypt,
-				.decrypt        = nss_cryptoapi_ablk_decrypt,
-			},
-		},
+			.cra_driver_name = "nss-rfc3686-ctr-aes",
+			.cra_priority   = 30000,
+			.cra_flags      = CRYPTO_ALG_TYPE_ABLKCIPHER | CRYPTO_ALG_ASYNC,
+			.cra_blocksize  = AES_BLOCK_SIZE,
+			.cra_ctxsize    = sizeof(struct nss_cryptoapi_ctx),
+			.cra_alignmask  = 0,
+			.cra_module     = THIS_MODULE,
+		},
+		.init       = nss_cryptoapi_ablkcipher_init,
+		.exit       = nss_cryptoapi_ablkcipher_exit,
+		.ivsize         = CTR_RFC3686_IV_SIZE,
+		.min_keysize    = AES_MIN_KEY_SIZE + CTR_RFC3686_NONCE_SIZE,
+		.max_keysize    = AES_MAX_KEY_SIZE + CTR_RFC3686_NONCE_SIZE,
+		.setkey         = nss_cryptoapi_ablk_setkey,
+		.encrypt        = nss_cryptoapi_ablk_encrypt,
+		.decrypt        = nss_cryptoapi_ablk_decrypt,
 	},
 	{
-		.cra_name = "ecb(aes)",
-		.cra_driver_name = "nss-ecb-aes",
-		.cra_priority = 10000,
-		.cra_flags = CRYPTO_ALG_TYPE_ABLKCIPHER | CRYPTO_ALG_ASYNC,
-		.cra_blocksize = AES_BLOCK_SIZE,
-		.cra_ctxsize = sizeof(struct nss_cryptoapi_ctx),
-		.cra_alignmask = 0,
-		.cra_type = &crypto_ablkcipher_type,
-		.cra_module = THIS_MODULE,
-		.cra_init = nss_cryptoapi_ablkcipher_init,
-		.cra_exit = nss_cryptoapi_ablkcipher_exit,
-		.cra_u = {
-			.ablkcipher = {
-				.min_keysize = AES_MIN_KEY_SIZE,
-				.max_keysize = AES_MAX_KEY_SIZE,
-				.setkey = nss_cryptoapi_ablk_setkey,
-				.encrypt = nss_cryptoapi_ablk_encrypt,
-				.decrypt = nss_cryptoapi_ablk_decrypt,
-			},
-		},
+		.base = {
+			.cra_name = "ecb(aes)",
+			.cra_driver_name = "nss-ecb-aes",
+			.cra_priority = 10000,
+			.cra_flags = CRYPTO_ALG_TYPE_ABLKCIPHER | CRYPTO_ALG_ASYNC,
+			.cra_blocksize = AES_BLOCK_SIZE,
+			.cra_ctxsize = sizeof(struct nss_cryptoapi_ctx),
+			.cra_alignmask = 0,
+			.cra_module = THIS_MODULE,
+		},
+		.init = nss_cryptoapi_ablkcipher_init,
+		.exit = nss_cryptoapi_ablkcipher_exit,
+		.min_keysize = AES_MIN_KEY_SIZE,
+		.max_keysize = AES_MAX_KEY_SIZE,
+		.setkey = nss_cryptoapi_ablk_setkey,
+		.encrypt = nss_cryptoapi_ablk_encrypt,
+		.decrypt = nss_cryptoapi_ablk_decrypt,
 	},
 	{
-		.cra_name = "cbc(des3_ede)",
-		.cra_driver_name = "nss-cbc-des-ede",
-		.cra_priority = 10000,
-		.cra_flags = CRYPTO_ALG_TYPE_ABLKCIPHER | CRYPTO_ALG_ASYNC,
-		.cra_blocksize = DES3_EDE_BLOCK_SIZE,
-		.cra_ctxsize = sizeof(struct nss_cryptoapi_ctx),
-		.cra_alignmask = 0,
-		.cra_type = &crypto_ablkcipher_type,
-		.cra_module = THIS_MODULE,
-		.cra_init = nss_cryptoapi_ablkcipher_init,
-		.cra_exit = nss_cryptoapi_ablkcipher_exit,
-		.cra_u = {
-			.ablkcipher = {
-				.ivsize = DES3_EDE_BLOCK_SIZE,
-				.min_keysize = DES3_EDE_KEY_SIZE,
-				.max_keysize = DES3_EDE_KEY_SIZE,
-				.setkey = nss_cryptoapi_ablk_setkey,
-				.encrypt = nss_cryptoapi_ablk_encrypt,
-				.decrypt = nss_cryptoapi_ablk_decrypt,
-			},
-		},
+		.base = {
+			.cra_name = "cbc(des3_ede)",
+			.cra_driver_name = "nss-cbc-des-ede",
+			.cra_priority = 10000,
+			.cra_flags = CRYPTO_ALG_TYPE_ABLKCIPHER | CRYPTO_ALG_ASYNC,
+			.cra_blocksize = DES3_EDE_BLOCK_SIZE,
+			.cra_ctxsize = sizeof(struct nss_cryptoapi_ctx),
+			.cra_alignmask = 0,
+			.cra_module = THIS_MODULE,
+		},
+		.init = nss_cryptoapi_ablkcipher_init,
+		.exit = nss_cryptoapi_ablkcipher_exit,
+		.ivsize = DES3_EDE_BLOCK_SIZE,
+		.min_keysize = DES3_EDE_KEY_SIZE,
+		.max_keysize = DES3_EDE_KEY_SIZE,
+		.setkey = nss_cryptoapi_ablk_setkey,
+		.encrypt = nss_cryptoapi_ablk_encrypt,
+		.decrypt = nss_cryptoapi_ablk_decrypt,
 	}
 };
 
 /*
  * AHASH algorithms
  */
diff --git a/cryptoapi/v2.0/nss_cryptoapi_ablk.c b/cryptoapi/v2.0/nss_cryptoapi_ablk.c
index 9b6c65e..913e9cc 100644
--- a/cryptoapi/v2.0/nss_cryptoapi_ablk.c
+++ b/cryptoapi/v2.0/nss_cryptoapi_ablk.c
@@ -64,53 +64,53 @@
  * nss_cryptoapi_skcipher_ctx2session()
  *	Cryptoapi function to get the session ID for an skcipher
  */
 int nss_cryptoapi_skcipher_ctx2session(struct crypto_skcipher *sk, uint32_t *sid)
 {
 	struct crypto_tfm *tfm = crypto_skcipher_tfm(sk);
-	struct crypto_ablkcipher **actx, *ablk;
-	struct ablkcipher_tfm *ablk_tfm;
+	struct crypto_skcipher **actx, *ablk;
+	struct skcipher_tfm *ablk_tfm;
 	struct nss_cryptoapi_ctx *ctx;
 
 	if (strncmp("nss-", crypto_tfm_alg_driver_name(tfm), 4))
 		return -EINVAL;
 
-	/* Get the ablkcipher from the skcipher */
+	/* Get the skcipher from the skcipher */
 	actx = crypto_skcipher_ctx(sk);
 	if (!actx || !(*actx))
 		return -EINVAL;
 
 	/*
-	 * The ablkcipher now obtained is a wrapper around the actual
-	 * ablkcipher that is created when the skcipher is created.
-	 * Hence we derive the required ablkcipher through ablkcipher_tfm.
+	 * The skcipher now obtained is a wrapper around the actual
+	 * skcipher that is created when the skcipher is created.
+	 * Hence we derive the required skcipher through skcipher_tfm.
 	 */
-	ablk_tfm = crypto_ablkcipher_crt(*actx);
+	ablk_tfm = crypto_skcipher_crt(*actx);
 	if (!ablk_tfm)
 		return -EINVAL;
 
 	ablk = ablk_tfm->base;
 	if (!ablk)
 		return -EINVAL;
 
-	/* Get the nss_cryptoapi context stored in the ablkcipher */
-	ctx = crypto_ablkcipher_ctx(ablk);
+	/* Get the nss_cryptoapi context stored in the skcipher */
+	ctx = crypto_skcipher_ctx(ablk);
 
 	BUG_ON(!ctx);
 	NSS_CRYPTOAPI_VERIFY_MAGIC(ctx);
 
 	*sid = ctx->sid;
 	return 0;
 }
 EXPORT_SYMBOL(nss_cryptoapi_skcipher_ctx2session);
 
 /*
- * nss_cryptoapi_ablkcipher_init()
- * 	Cryptoapi ablkcipher init function.
+ * nss_cryptoapi_skcipher_init()
+ * 	Cryptoapi skcipher init function.
  */
-int nss_cryptoapi_ablkcipher_init(struct crypto_tfm *tfm)
+int nss_cryptoapi_skcipher_init(struct crypto_tfm *tfm)
 {
 	struct nss_cryptoapi_ctx *ctx = crypto_tfm_ctx(tfm);
 
 	BUG_ON(!ctx);
 	NSS_CRYPTOAPI_SET_MAGIC(ctx);
 
@@ -122,16 +122,16 @@
 	init_completion(&ctx->complete);
 
 	return 0;
 }
 
 /*
- * nss_cryptoapi_ablkcipher_exit()
- * 	Cryptoapi ablkcipher exit function.
+ * nss_cryptoapi_skcipher_exit()
+ * 	Cryptoapi skcipher exit function.
  */
-void nss_cryptoapi_ablkcipher_exit(struct crypto_tfm *tfm)
+void nss_cryptoapi_skcipher_exit(struct crypto_tfm *tfm)
 {
 	struct nss_cryptoapi_ctx *ctx = crypto_tfm_ctx(tfm);
 	int ret;
 
 	BUG_ON(!ctx);
 	NSS_CRYPTOAPI_VERIFY_MAGIC(ctx);
@@ -177,31 +177,31 @@
 }
 
 /*
  * nss_cryptoapi_ablk_setkey()
  * 	Cryptoapi setkey routine for aes.
  */
-int nss_cryptoapi_ablk_setkey(struct crypto_ablkcipher *cipher, const u8 *key, unsigned int keylen)
+int nss_cryptoapi_ablk_setkey(struct crypto_skcipher *cipher, const u8 *key, unsigned int keylen)
 {
-	struct crypto_tfm *tfm = crypto_ablkcipher_tfm(cipher);
+	struct crypto_tfm *tfm = crypto_skcipher_tfm(cipher);
 	struct nss_cryptoapi_ctx *ctx = crypto_tfm_ctx(tfm);
 	struct nss_crypto_session_data data = {0};
 	int status;
 
 	/*
 	 * Validate magic number - init should be called before setkey
 	 */
 	NSS_CRYPTOAPI_VERIFY_MAGIC(ctx);
 
 	ctx->info = nss_cryptoapi_cra_name2info(crypto_tfm_alg_name(tfm), keylen, 0);
 	if (!ctx->info) {
-		crypto_ablkcipher_set_flags(cipher, CRYPTO_TFM_RES_BAD_KEY_LEN);
+		crypto_skcipher_set_flags(cipher, CRYPTO_TFM_RES_BAD_KEY_LEN);
 		return -EINVAL;
 	}
 
-	ctx->iv_size = crypto_ablkcipher_ivsize(cipher);
+	ctx->iv_size = crypto_skcipher_ivsize(cipher);
 
 	if (ctx->info->cipher_mode == NSS_CRYPTOAPI_CIPHER_MODE_CTR_RFC3686) {
 		keylen = keylen - CTR_RFC3686_NONCE_SIZE;
 		memcpy(ctx->ctx_iv, key + keylen, CTR_RFC3686_NONCE_SIZE);
 		ctx->ctx_iv[3] = ntohl(0x1);
 		ctx->iv_size += CTR_RFC3686_NONCE_SIZE + sizeof(uint32_t);
@@ -222,29 +222,29 @@
 		ctx->sid = NSS_CRYPTO_SESSION_MAX;
 	}
 
 	status = nss_crypto_session_alloc(ctx->user, &data, &ctx->sid);
 	if (status < 0) {
 		nss_cfi_err("%px: Unable to allocate crypto session(%d)\n", ctx, status);
-		crypto_ablkcipher_set_flags(cipher, CRYPTO_TFM_RES_BAD_FLAGS);
+		crypto_skcipher_set_flags(cipher, CRYPTO_TFM_RES_BAD_FLAGS);
 		return status;
 	}
 
 	nss_cryptoapi_add_ctx2debugfs(ctx);
 	atomic_set(&ctx->active, 1);
 	atomic_set(&ctx->refcnt, 1);
 	return 0;
 }
 
 /*
- * nss_cryptoapi_ablkcipher_done()
+ * nss_cryptoapi_skcipher_done()
  * 	Cipher operation completion callback function
  */
-void nss_cryptoapi_ablkcipher_done(void *app_data, struct nss_crypto_hdr *ch, uint8_t status)
+void nss_cryptoapi_skcipher_done(void *app_data, struct nss_crypto_hdr *ch, uint8_t status)
 {
-	struct ablkcipher_request *req = app_data;
+	struct skcipher_request *req = app_data;
 	struct nss_cryptoapi_ctx *ctx = crypto_tfm_ctx(req->base.tfm);
 	int error;
 
 	BUG_ON(!ch);
 
 	/*
@@ -254,22 +254,22 @@
 
 	/*
 	 * For skcipher decryption case, the last block of encrypted data is used as
 	 * an IV for the next data
 	 */
 	if (ch->op == NSS_CRYPTO_OP_DIR_ENC) {
-		nss_cryptoapi_copy_iv(ctx, req->dst, req->info, ch->iv_len);
+		nss_cryptoapi_copy_iv(ctx, req->dst, req->iv, ch->iv_len);
 	}
 
 	/*
 	 * Free crypto hdr
 	 */
 	nss_crypto_hdr_free(ctx->user, ch);
 
 	nss_cfi_dbg("data dump after transformation\n");
-	nss_cfi_dbg_data(sg_virt(req->dst), req->nbytes, ' ');
+	nss_cfi_dbg_data(sg_virt(req->dst), req->cryptlen, ' ');
 
 	/*
 	 * Check if there is any error reported by hardware
 	 */
 	error = nss_cryptoapi_status2error(ctx, status);
 	ctx->stats.completed++;
@@ -282,17 +282,17 @@
 }
 
 /*
  * nss_cryptoapi_ablk_encrypt()
  * 	Crytoapi encrypt for AES and 3DES algorithms.
  */
-int nss_cryptoapi_ablk_encrypt(struct ablkcipher_request *req)
+int nss_cryptoapi_ablk_encrypt(struct skcipher_request *req)
 {
 	struct nss_cryptoapi_info info = {.op_dir = NSS_CRYPTO_OP_DIR_ENC};
-	struct crypto_ablkcipher *cipher = crypto_ablkcipher_reqtfm(req);
-	struct nss_cryptoapi_ctx *ctx = crypto_ablkcipher_ctx(cipher);
+	struct crypto_skcipher *cipher = crypto_skcipher_reqtfm(req);
+	struct nss_cryptoapi_ctx *ctx = crypto_skcipher_ctx(cipher);
 	struct crypto_tfm *tfm = req->base.tfm;
 	struct scatterlist *cur;
 	int tot_len = 0;
 	int i;
 
 	/*
@@ -312,68 +312,68 @@
 	}
 
 	/*
 	 * Block size not aligned.
 	 * AES-CTR requires only a one-byte block size alignment.
 	 */
-	if (!IS_ALIGNED(req->nbytes, crypto_tfm_alg_blocksize(tfm)) && ctx->info->blk_align) {
+	if (!IS_ALIGNED(req->cryptlen, crypto_tfm_alg_blocksize(tfm)) && ctx->info->blk_align) {
 		ctx->stats.failed_align++;
-		crypto_ablkcipher_set_flags(cipher, CRYPTO_TFM_RES_BAD_BLOCK_LEN);
+		crypto_skcipher_set_flags(cipher, CRYPTO_TFM_RES_BAD_BLOCK_LEN);
 		return -EFAULT;
 	}
 
 	/*
 	 * Fill the request information structure
 	 */
-	info.iv = req->info;
+	info.iv = req->iv;
 	info.src.nsegs = sg_nents(req->src);
 	info.dst.nsegs = sg_nents(req->dst);
 	info.op_dir = NSS_CRYPTO_OP_DIR_ENC;
-	info.cb = nss_cryptoapi_ablkcipher_done;
+	info.cb = nss_cryptoapi_skcipher_done;
 	info.iv_size = ctx->iv_size;
 	info.src.first_sg = req->src;
 	info.dst.first_sg = req->dst;
 	info.dst.last_sg = sg_last(req->dst, info.dst.nsegs);
 
 	/* out and in length will be same as ablk does only encrypt/decryt operation */
-	info.total_in_len = info.total_out_len = req->nbytes;
+	info.total_in_len = info.total_out_len = req->cryptlen;
 	info.in_place = (req->src == req->dst) ? true : false;
 
 	/*
 	 * The exact length of data that needs to be ciphered for an ABLK
-	 * request is stored in req->nbytes. Hence we may have to reduce
-	 * the DMA length to what is specified in req->nbytes and later
+	 * request is stored in req->cryptlen. Hence we may have to reduce
+	 * the DMA length to what is specified in req->cryptlen and later
 	 * restore the length of scatterlist back to its original value.
 	 */
 	for_each_sg(req->src, cur, info.src.nsegs, i) {
 		if (!cur)
 			break;
 
 		tot_len += cur->length;
 		if (!sg_next(cur))
 			break;
 	}
 
 	info.src.last_sg = cur;
-	info.ahash_skip = tot_len - req->nbytes;
+	info.ahash_skip = tot_len - req->cryptlen;
 
 	if (!atomic_inc_not_zero(&ctx->refcnt))
 		return -ENOENT;
 
 	return nss_cryptoapi_transform(ctx, &info, (void *)req, false);
 }
 
 /*
  * nss_cryptoapi_ablk_decrypt()
  * 	Crytoapi decrypt for AES and 3DES CBC algorithms.
  */
-int nss_cryptoapi_ablk_decrypt(struct ablkcipher_request *req)
+int nss_cryptoapi_ablk_decrypt(struct skcipher_request *req)
 {
 	struct nss_cryptoapi_info info = {.op_dir = NSS_CRYPTO_OP_DIR_DEC};
-	struct crypto_ablkcipher *cipher = crypto_ablkcipher_reqtfm(req);
-	struct nss_cryptoapi_ctx *ctx = crypto_ablkcipher_ctx(cipher);
+	struct crypto_skcipher *cipher = crypto_skcipher_reqtfm(req);
+	struct nss_cryptoapi_ctx *ctx = crypto_skcipher_ctx(cipher);
 	struct crypto_tfm *tfm = req->base.tfm;
 	struct scatterlist *cur;
 	int tot_len = 0;
 	int i;
 
 	/*
@@ -392,55 +392,55 @@
 		return -EINVAL;
 	}
 
 	/*
 	 * Block size not aligned
 	 */
-	if (!IS_ALIGNED(req->nbytes, crypto_tfm_alg_blocksize(tfm)) && ctx->info->blk_align) {
+	if (!IS_ALIGNED(req->cryptlen, crypto_tfm_alg_blocksize(tfm)) && ctx->info->blk_align) {
 		ctx->stats.failed_align++;
-		crypto_ablkcipher_set_flags(cipher, CRYPTO_TFM_RES_BAD_BLOCK_LEN);
+		crypto_skcipher_set_flags(cipher, CRYPTO_TFM_RES_BAD_BLOCK_LEN);
 		return -EFAULT;
 	}
 
 	/*
 	 * Fill the request information structure
 	 * Note: For CTR mode, IV size will be set to AES_BLOCK_SIZE.
 	 * This is because linux gives iv size as 8 while we need to alloc 16 bytes
 	 * in crypto hdr to accomodate
 	 * - 4 bytes of nonce
 	 * - 8 bytes of IV
 	 * - 4 bytes of initial counter
 	 */
-	info.iv = req->info;
+	info.iv = req->iv;
 	info.src.nsegs = sg_nents(req->src);
 	info.dst.nsegs = sg_nents(req->dst);
 	info.iv_size = ctx->iv_size;
 	info.op_dir = NSS_CRYPTO_OP_DIR_DEC;
-	info.cb = nss_cryptoapi_ablkcipher_done;
+	info.cb = nss_cryptoapi_skcipher_done;
 	info.src.first_sg = req->src;
 	info.dst.first_sg = req->dst;
 	info.dst.last_sg = sg_last(req->dst, info.dst.nsegs);
 
 	/* out and in length will be same as ablk does only encrypt/decryt operation */
-	info.total_in_len = info.total_out_len = req->nbytes;
+	info.total_in_len = info.total_out_len = req->cryptlen;
 	info.in_place = (req->src == req->dst) ? true : false;
 
 	/*
 	 * The exact length of data that needs to be ciphered for an ABLK
-	 * request is stored in req->nbytes. Hence we may have to reduce
-	 * the DMA length to what is specified in req->nbytes and later
+	 * request is stored in req->cryptlen. Hence we may have to reduce
+	 * the DMA length to what is specified in req->cryptlen and later
 	 * restore the length of scatterlist back to its original value.
 	 */
 	for_each_sg(req->src, cur, info.src.nsegs, i) {
 		tot_len += cur->length;
 		if (!sg_next(cur))
 			break;
 	}
 
-	info.ahash_skip = tot_len - req->nbytes;
+	info.ahash_skip = tot_len - req->cryptlen;
 	info.src.last_sg = cur;
 
 	if (!atomic_inc_not_zero(&ctx->refcnt))
 		return -ENOENT;
 
 	return nss_cryptoapi_transform(ctx, &info, (void *)req, false);
 }
diff --git a/cryptoapi/v2.0/nss_cryptoapi_private.h b/cryptoapi/v2.0/nss_cryptoapi_private.h
index 5feb9e3..70c6714 100644
--- a/cryptoapi/v2.0/nss_cryptoapi_private.h
+++ b/cryptoapi/v2.0/nss_cryptoapi_private.h
@@ -243,19 +243,19 @@
 extern void nss_cryptoapi_aead_seqiv_tx_proc(struct nss_cryptoapi_ctx *ctx, struct aead_request *req,
 				struct nss_cryptoapi_info *info, bool encrypt);
 extern void nss_cryptoapi_aead_tx_proc(struct nss_cryptoapi_ctx *ctx, struct aead_request *req,
 				struct nss_cryptoapi_info *info, bool encrypt);
 
 /*
- * ABLKCIPHER
+ * skcipher
  */
-extern int nss_cryptoapi_ablkcipher_init(struct crypto_tfm *tfm);
-extern void nss_cryptoapi_ablkcipher_exit(struct crypto_tfm *tfm);
-extern int nss_cryptoapi_ablk_setkey(struct crypto_ablkcipher *cipher, const u8 *key, unsigned int len);
-extern int nss_cryptoapi_ablk_encrypt(struct ablkcipher_request *req);
-extern int nss_cryptoapi_ablk_decrypt(struct ablkcipher_request *req);
+extern int nss_cryptoapi_skcipher_init(struct crypto_tfm *tfm);
+extern void nss_cryptoapi_skcipher_exit(struct crypto_tfm *tfm);
+extern int nss_cryptoapi_ablk_setkey(struct crypto_skcipher *cipher, const u8 *key, unsigned int len);
+extern int nss_cryptoapi_ablk_encrypt(struct skcipher_request *req);
+extern int nss_cryptoapi_ablk_decrypt(struct skcipher_request *req);
 extern void nss_cryptoapi_copy_iv(struct nss_cryptoapi_ctx *ctx, struct scatterlist *sg, uint8_t *iv, uint8_t iv_len);
 
 /*
  * AHASH
  */
 extern int nss_cryptoapi_ahash_cra_init(struct crypto_tfm *tfm);
